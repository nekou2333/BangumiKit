// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

public extension Paths.V0.Search {
    var persons: Persons {
        Persons(path: path + "/persons")
    }

    struct Persons {
        /// Path: `/v0/search/persons`
        public let path: String

        /// 人物搜索
        ///
        /// ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动
        ///
        /// 目前支持的筛选条件包括:
        /// - `career`: 职业，可以多次出现。`且` 关系。
        ///
        /// 不同筛选条件之间为 `且`
        public func post(limit: Int? = nil, offset: Int? = nil, _ body: PostRequest? = nil) -> Request<BangumiKit.PagedPerson> {
            Request(path: path, method: "POST", query: makePostQuery(limit, offset), body: body, id: "searchPersons")
        }

        private func makePostQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            public var keyword: String
            /// 不同条件之间是 `且` 的关系
            public var filter: Filter?

            /// 不同条件之间是 `且` 的关系
            public struct Filter: Encodable {
                /// 职业，可以多次出现。多值之间为 `且` 关系。
                ///
                /// Example: ["artist", "director"]
                public var career: [String]?

                public init(career: [String]? = nil) {
                    self.career = career
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(career, forKey: "career")
                }
            }

            public init(keyword: String, filter: Filter? = nil) {
                self.keyword = keyword
                self.filter = filter
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(keyword, forKey: "keyword")
                try values.encodeIfPresent(filter, forKey: "filter")
            }
        }
    }
}
