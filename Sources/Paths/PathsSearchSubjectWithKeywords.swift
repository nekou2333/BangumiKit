// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

public extension Paths.Search.Subject {
    func keywords(_ keywords: String) -> WithKeywords {
        WithKeywords(path: "\(path)/\(keywords)")
    }

    struct WithKeywords {
        /// Path: `/search/subject/{keywords}`
        public let path: String

        /// 条目搜索
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(path: path, method: "GET", query: parameters?.asQuery, id: "searchSubjectByKeywords")
        }

        public enum GetResponse: Decodable {
            case a(A)
            case b(B)
            case c(C)

            public struct A: Decodable {
                /// 总条数
                public var results: Int?
                /// 结果列表
                public var list: [BangumiKit.LegacySubjectSmall]?

                public init(results: Int? = nil, list: [BangumiKit.LegacySubjectSmall]? = nil) {
                    self.results = results
                    self.list = list
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.results = try values.decodeIfPresent(Int.self, forKey: "results")
                    self.list = try values.decodeIfPresent([BangumiKit.LegacySubjectSmall].self, forKey: "list")
                }
            }

            public struct B: Decodable {
                /// 总条数
                public var results: Int?
                /// 结果列表
                public var list: [BangumiKit.LegacySubjectMedium]?

                public init(results: Int? = nil, list: [BangumiKit.LegacySubjectMedium]? = nil) {
                    self.results = results
                    self.list = list
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.results = try values.decodeIfPresent(Int.self, forKey: "results")
                    self.list = try values.decodeIfPresent([BangumiKit.LegacySubjectMedium].self, forKey: "list")
                }
            }

            public struct C: Decodable {
                /// 总条数
                public var results: Int?
                /// 结果列表
                public var list: [BangumiKit.LegacySubjectLarge]?

                public init(results: Int? = nil, list: [BangumiKit.LegacySubjectLarge]? = nil) {
                    self.results = results
                    self.list = list
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.results = try values.decodeIfPresent(Int.self, forKey: "results")
                    self.list = try values.decodeIfPresent([BangumiKit.LegacySubjectLarge].self, forKey: "list")
                }
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode(A.self) {
                    self = .a(value)
                } else if let value = try? container.decode(B.self) {
                    self = .b(value)
                } else if let value = try? container.decode(C.self) {
                    self = .c(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types (A, B, C)."
                    )
                }
            }
        }

        public struct GetParameters {
            /// 条目类型 <br> 1 = book <br> 2 = anime <br> 3 = music <br> 4 = game <br> 6 = real
            public var type: Int?
            /// 返回数据大小
            public var responseGroup: ResponseGroup?
            public var start: Int?
            public var maxResults: Int?

            /// 返回数据大小
            public enum ResponseGroup: String, Codable, CaseIterable {
                case small
                case medium
                case large
            }

            public init(type: Int? = nil, responseGroup: ResponseGroup? = nil, start: Int? = nil, maxResults: Int? = nil) {
                self.type = type
                self.responseGroup = responseGroup
                self.start = start
                self.maxResults = maxResults
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(responseGroup, forKey: "responseGroup")
                encoder.encode(start, forKey: "start")
                encoder.encode(maxResults, forKey: "max_results")
                return encoder.items
            }
        }
    }
}
