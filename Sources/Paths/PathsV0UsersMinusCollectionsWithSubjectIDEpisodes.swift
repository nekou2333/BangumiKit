// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

public extension Paths.V0.Users.Minus.Collections.WithSubjectID {
    var episodes: Episodes {
        Episodes(path: path + "/episodes")
    }

    struct Episodes {
        /// Path: `/v0/users/-/collections/{subject_id}/episodes`
        public let path: String

        /// 章节收藏信息
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            Request(path: path, method: "GET", query: parameters?.asQuery, id: "getUserSubjectEpisodeCollection")
        }

        public struct GetResponse: Decodable {
            public var total: Int
            public var limit: Int
            public var offset: Int
            public var data: [BangumiKit.UserEpisodeCollection]?

            public init(total: Int, limit: Int, offset: Int, data: [BangumiKit.UserEpisodeCollection]? = nil) {
                self.total = total
                self.limit = limit
                self.offset = offset
                self.data = data
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.total = try values.decode(Int.self, forKey: "total")
                self.limit = try values.decode(Int.self, forKey: "limit")
                self.offset = try values.decode(Int.self, forKey: "offset")
                self.data = try values.decodeIfPresent([BangumiKit.UserEpisodeCollection].self, forKey: "data")
            }
        }

        public struct GetParameters {
            public var offset: Int?
            public var limit: Int?
            /// EpType
            ///
            /// 本篇 = 0
            /// 特别篇 = 1
            /// OP = 2
            /// ED = 3
            /// 预告/宣传/广告 = 4
            /// MAD = 5
            /// 其他 = 6
            public var episodeType: Int?

            public init(offset: Int? = nil, limit: Int? = nil, episodeType: Int? = nil) {
                self.offset = offset
                self.limit = limit
                self.episodeType = episodeType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(offset, forKey: "offset")
                encoder.encode(limit, forKey: "limit")
                encoder.encode(episodeType, forKey: "episode_type")
                return encoder.items
            }
        }

        /// 章节收藏信息
        ///
        /// 同时会重新计算条目的完成度
        public func patch(_ body: PatchRequest? = nil) -> Request<Void> {
            Request(path: path, method: "PATCH", body: body, id: "patchUserSubjectEpisodeCollection")
        }

        public struct PatchRequest: Encodable {
            /// Example: [1, 2, 8]
            public var episodeID: [Int]
            /// EpisodeCollectionType
            ///
            /// - `0`: 未收藏
            /// - `1`: 想看
            /// - `2`: 看过
            /// - `3`: 抛弃
            public var type: Int

            public init(episodeID: [Int], type: Int) {
                self.episodeID = episodeID
                self.type = type
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(episodeID, forKey: "episode_id")
                try values.encode(type, forKey: "type")
            }
        }
    }
}
