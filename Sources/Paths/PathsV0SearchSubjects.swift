// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import URLQueryEncoder

public extension Paths.V0.Search {
    var subjects: Subjects {
        Subjects(path: path + "/subjects")
    }

    struct Subjects {
        /// Path: `/v0/search/subjects`
        public let path: String

        /// 条目搜索
        ///
        /// ## 实验性 API， 本 schema 和实际的 API 行为都可能随时发生改动
        ///
        /// 目前支持的筛选条件包括:
        /// - `type`: 条目类型，参照 `SubjectType` enum， `或`。
        /// - `tag`: 标签，可以多次出现。`且` 关系。
        /// - `airdate`: 播出日期/发售日期。`且` 关系。
        /// - `rating`: 用于搜索指定评分的条目。`且` 关系。
        /// - `rank`: 用于搜索指定排名的条目。`且` 关系。
        /// - `nsfw`: 使用 `include` 包含NSFW搜索结果。默认排除搜索NSFW条目。无权限情况下忽略此选项，不会返回NSFW条目。
        ///
        /// 不同筛选条件之间为 `且`
        public func post(limit: Int? = nil, offset: Int? = nil, _ body: PostRequest? = nil) -> Request<BangumiKit.PagedSubject> {
            Request(path: path, method: "POST", query: makePostQuery(limit, offset), body: body, id: "searchSubjects")
        }

        private func makePostQuery(_ limit: Int?, _ offset: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(limit, forKey: "limit")
            encoder.encode(offset, forKey: "offset")
            return encoder.items
        }

        public struct PostRequest: Encodable {
            public var keyword: String
            /// 排序规则
            ///
            /// - `match` meilisearch 的默认排序，按照匹配程度
            /// - `heat` 收藏人数
            /// - `rank` 排名由高到低
            /// - `score` 评分
            ///
            /// Example: "rank"
            public var sort: Sort?
            /// 不同条件之间是 `且` 的关系
            public var filter: Filter?

            /// 排序规则
            ///
            /// - `match` meilisearch 的默认排序，按照匹配程度
            /// - `heat` 收藏人数
            /// - `rank` 排名由高到低
            /// - `score` 评分
            ///
            /// Example: "rank"
            public enum Sort: String, Codable, CaseIterable {
                case match
                case heat
                case rank
                case score
            }

            /// 不同条件之间是 `且` 的关系
            public struct Filter: Encodable {
                /// 条目类型，参照 `SubjectType` enum，多值之间为 `或` 的关系。
                public var type: [Int]?
                /// 公共标签。多个值之间为 `且` 关系。可以用 `-` 排除标签。比如 `-科幻` 可以排除科幻标签。
                ///
                /// Example: ["童年", "原创"]
                public var metaTags: [String]?
                /// 标签，可以多次出现。多值之间为 `且` 关系。
                ///
                /// Example: ["童年", "原创"]
                public var tag: [String]?
                /// 播出日期/发售日期，日期必需为 `YYYY-MM-DD` 格式。多值之间为 `且` 关系。
                ///
                /// Example: [">=2020-07-01", "<2020-10-01"]
                public var airDate: [String]?
                /// 用于搜索指定评分的条目，多值之间为 `且` 关系。
                ///
                /// Example: [">=6", "<8"]
                public var rating: [String]?
                /// 用于搜索指定排名的条目，多值之间为 `且` 关系。
                ///
                /// Example: [">10", "<=18"]
                public var rank: [String]?
                /// 无权限的用户会直接忽略此字段，不会返回R18条目。
                ///
                /// 默认或者 `null` 会返回包含 R18 的所有搜索结果。
                ///
                /// `true` 只会返回 R18 条目。
                ///
                /// `false` 只会返回非 R18 条目。
                public var isNsfw: Bool?

                public init(
                    type: [Int]? = nil,
                    metaTags: [String]? = nil,
                    tag: [String]? = nil,
                    airDate: [String]? = nil,
                    rating: [String]? = nil,
                    rank: [String]? = nil,
                    isNsfw: Bool? = nil
                ) {
                    self.type = type
                    self.metaTags = metaTags
                    self.tag = tag
                    self.airDate = airDate
                    self.rating = rating
                    self.rank = rank
                    self.isNsfw = isNsfw
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(type, forKey: "type")
                    try values.encodeIfPresent(metaTags, forKey: "meta_tags")
                    try values.encodeIfPresent(tag, forKey: "tag")
                    try values.encodeIfPresent(airDate, forKey: "air_date")
                    try values.encodeIfPresent(rating, forKey: "rating")
                    try values.encodeIfPresent(rank, forKey: "rank")
                    try values.encodeIfPresent(isNsfw, forKey: "nsfw")
                }
            }

            public init(keyword: String, sort: Sort? = nil, filter: Filter? = nil) {
                self.keyword = keyword
                self.sort = sort
                self.filter = filter
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(keyword, forKey: "keyword")
                try values.encodeIfPresent(sort, forKey: "sort")
                try values.encodeIfPresent(filter, forKey: "filter")
            }
        }
    }
}
